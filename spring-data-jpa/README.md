# Shop (Spring-Data-JPA 데모)
## 1. 웹 

### 1.1 기능 구현 
- 회원 기능
  - 회원 등록/조회
- 상품 기능
  - 상품 등록/수정/조회
- 주문 기능
  - 상품 주문
  - 주문 내역 조회
  - 주문 취소
- 기타 요구사항
  - 상품은 재고 관리가 필요하다.
  - 상품의 종류는 도서, 음반, 영화가 있다.
  - 상품을 카테고리로 구분할 수 있다.
  - 상품 주문시 배송 정보를 입력할 수 있다.

예제를 단순화하기 위해 다음 기능은 구현하지 않습니다.
- 로그인과 권한 관리X 
- 파라미터 검증과 예외 처리 단순화
- 상품은 도서만 사용
- 카테고리는 사용X
- 배송 정보는 사용X 
### 1.2 설계
#### 1.2.1 엔티티 설계
Category와 Item 관계를 보면 N:M 관계로 나타냈는데, 이는 JPA를 학습하는 차원에서 나타낸 것일뿐 실무에서는 1:N, M:1 관계로 풀어서 나타내야 합니다. 
또한, Member와 Order를 보면 양방향 연관 관계로 설정을 해두었는데, 이또한 마찬가지로 학습하는 차원에서 양방향으로 설정해둔 것일뿐
실무에서는 되도록 단방향 연관 관계로 끝내는 것이 좋습니다. <br/>

<p align="center">
<img src="https://user-images.githubusercontent.com/31037742/144737239-0b341b40-1c0d-4240-ba79-56e46a9cda6f.png">
</p>

#### 1.2.2 ERD 설계

<p align="center">
<img src="https://user-images.githubusercontent.com/31037742/144738947-3a8f9511-44c6-474b-9160-4812822561d3.png">
</p>

### 1.3 주의사항
#### 1.3.1 Entity 설계시 주의점
- Entity에는 가급적 Setter를 사용하지 말자. (변경 포인트가 너무 많아서 유지보수가 어렵다.)
- 모든 연관 관계는 지연로딩(LAZY)으로 설정하자.
  - 즉시로딩(EAGER)은 예측이 어렵고, 어떤 SQL이 실행될지 추적하기 어렵다. 특히 JPQL을 실행할 때 N+1 문제가 자주 발생한다.
  - 연관된 Entity를 함께 DB에서 조회해야 한다면, fetch join 또는 Entity 그래프 탐색을 사용하자.
- 컬렉션 필드는 기본적으로 new ArrayList<>()와 같이 초기화를 해두자.
  - NPE 방지 
  - Hibernate는 Entity를 영속화할 때, 컬렉션을 감싸서 Hibernate가 제공하는 내장 컬렉션으로 변경한다. 만약 <code>getOrders()</code>처럼 임의의 
  메서드에서 컬렉션을 잘못 생성하면 Hibernate 내부 메커니즘에 문제가 발생할 수 있다. 따라서 필드 레벨에서 생성하는 것이 가장 안전하고, 코드도 간결하다.

#### 1.3.2 변경 감지와 병합(merge)
변경 감지 기능을 사용하면 원하는 속성만 선택해서 변경할 수 있지만, 병합을 사용하면 모든 속성이 변경됩니다. 즉, 병합시 값이 없으면 <code>null</code>로 업데이트 할 위험이 있습니다.

### 1.4 애플리케이션 아키텍쳐
계층형 구조 사용
- controller, web: 웹 계층
- service: 비즈니스 로직, 트랜잭션 처리
- repository: JPA를 직접 사용하는 계층, EntityManager 사용
- domain: Entity가 모여있는 계층, 모든 계층에서 사용

패키지 구조
- com.demo.jpashop
  - domain
  - exception
  - repository
  - service
  - web

개발 순서
1. 서비스, 리포지토리 계층을 개발
2. 테스트 케이스를 작성해서 검증
3. 마지막에 웹 계층 적용

#### 1.4.1 도메인 모델 패턴 vs 트랜잭션 스크립트 패턴
주문 서비스의 주문과 주문 취소 메서드를 보면 대부분의 비즈니스 로직이 Entity에 있습니다. 서비스 계층은 단순히 엔티티에
필요한 요청을 위임하는 역할을 합니다. 이처럼 Entity가 비즈니스 로직을 가지고 객체 지향의 특성을 적극 활용하는 것을 도메인 모델 패턴이라고 합니다.
반대로 Entity에는 비즈니스 로직이 거의 없고 서비스 계층에서 대부분의 비즈니스 로직을 처리하는 것을 트랜잭션 스크립트 패턴이라고 합니다.

## 2. API와 성능 최적화 

### 2.1 다대일 관계(@ManyToOne, @OneToOne)

- Controller에서 반환 값으로 Entity 클래스를 직접 사용하지 말자. <br/>
  Entity는 여러 API에서 사용될 여지가 있는데, Entity가 변경될 경우 참조하는 모든 API 스펙이 같이 변경되버립니다.
- 대신 Controller에서 반환 값으로 해당 API 스펙에 맞는 DTO를 만들어 사용하자. <br/>
  주의할 점은, DTO 내에 필드 타입으로 Entity를 직접 사용하면, 또 다시 의존성 문제가 생기니, 필요한 것만 변수로 적어줘야합니다.
- 1+N 문제를 극복하기 위해, 페치 조인(join fetch)을 적극 활용하자.

### 2.2 일대다 관계(@OneToMany)

- 1쪽에서 N쪽으로 JOIN하면 결과 row 수가 증가합니다. (JPA가 아닌 Database 이슈) <br/>
  JPQL에서 select문에 distinct 키워드를 사용해서 같은 id 값을 가진 데이터 중복을 제거합니다. (JPA가 메모리에서 진행)
- 일대다 관계에서 페치 조인을 하면 DB단에서 쿼리로 Limit와 같은 페이징 처리를 할 수 없습니다. (치명적 단점) <br/>
  일대다 관계에서 JOIN을 할 경우 데이터 row 수가 증가되는 문제로 인해, 메모리에 모든 데이터를 불러온 후 메모리단에서 JPA가 페이징 처리를 합니다.
- 일대다 관계 페치 조인(컬렉션 페치 조인)은 1개만 사용할 수 있습니다.
- 결론적으로 다대일 관계는 페치 조인을 사용하고, 일대다 관계는 페치 조인을 사용하지 않습니다. <br/>
  컬렉션은 지연 로딩으로 조회하는데요, 이때 최적화를 위해 <code>@BatchSize</code> 를 사용합니다. <br/>
  - hibernate.default_batch_fetch_size: 글로벌 설정 (100~1000 사이즈가 권장됩니다.)
  - @BatchSize: 개별 최적화 

### 2.3 권장 순서 

1. Entity 조회 방식으로 우선 접근
   1. 페치 조인으로 쿼리 수를 최적화
   2. 컬렉션 최적화 
      1. 페이징 필요 -> hibernate.default_batch_fetch_size, @BatchSize 로 최적화 
      2. 페이징 필요X -> 페치 조인 사용 
2. Entity 조회 방식으로 해결이 안되면 DTO 조회 방식 사용 
3. DTO 조회 방식으로 해결이 안되면 NativeSQL or Spring JDBCTemplate 사용


| 참고: 개발자는 성능 최적화와 코드 복잡도 사이에서 줄타기를 해야 합니다. 대부분의 경우, 성능 최적화와 코드 복잡도는 반비례합니다.
| Entity 조회 방식은 JPA가 많은 부분을 최적화해주기 때문에, 단순한 코드를 유지하면서 성능을 최적화할 수 있습니다.
| 반면, DTO 조회 방식은 SQL을 직접 다루는 것과 유사하기 때문에, 서로 장단점이 있습니다.





